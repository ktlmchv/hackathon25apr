import coxeter
import data.int.basic
import group_theory.specific_groups.cyclic

noncomputable theory
open_locale classical

section lists
/- Lemmas about list coercions -/

variables {S : Type*} {T : set S}

-- Coercion from `list T` to `list S`.
instance list_subtype_to_list : has_coe (list T) (list S) :=
⟨λ l, list.map subtype.val l⟩

lemma coe_cons (hd : T) (tl : list T) : (coe (hd :: tl) : list S) = coe hd :: coe tl := 
rfl

lemma coe_append (l m : list T) : (coe (l ++ m) : list S) = l ++ m :=
begin
   rw coe, rw list_subtype_to_list, apply list.map_append,
end

lemma coe_reverse (l : list T) : (l.reverse : list S) = (l : list S).reverse :=
begin
   induction l with hd tl ih,
   { refl },
   simp [coe_append, coe_cons, ih],
   refl,
end

end lists

-- A group `W` generated by a set `S`, such that `S` contains `1` and `S⁻¹ = S`.
class generated_group (W : Type*) [group W] (S : set W) :=
(inv : S⁻¹ = S) 
(neut : (1 : W) ∉ S)
(gen : ∀ w : W, ∃ l : list S, (l : list W).prod = w)

namespace generated_group

variables {W : Type*} [group W] (S : set W)

/- Some more trivial coercion results -/
instance [h : generated_group W S] : has_inv S :=
⟨λ s,
{ val := s⁻¹,
  property := begin
   apply subset_of_eq h.inv,
   simp,
  end }⟩

lemma list_coe_inv [generated_group W S] (l : list S) :
   (coe (l.map has_inv.inv) : list W) = (coe l : list W).map has_inv.inv :=
begin
   induction l with hd tl ih,
   { refl },
   simp [coe_cons, ih],
   refl,
end

def gen_by_n (w : W) (n : ℕ) := ∃ l : list S, (l: list W).prod = w ∧ l.length = n
#check gen_by_n

lemma len_exists [h : generated_group W S] (w : W) : ∃ n, gen_by_n S w n :=
begin
   have h := h.gen w,
   induction h,
   use h_w.length,
   unfold gen_by_n,
   use h_w, 
   split, exact h_h, refl, 
end

-- The length of a group element with respect to a generating set `S`.
-- Bourbaki, Definition 4.1.1
def gen_length [generated_group W S] (w : W) := nat.find (len_exists S w) 
#check gen_length

variables [generated_group W S]

-- A list of elements is reduced it has minimal length amongs all lists with the same product.
-- Bourbaki, Definition 4.1.1
def is_reduced (S : set W) (w : W) [generated_group W S] (l : list S) :=
(l : list W).prod = w ∧ l.length = gen_length S w

lemma reduced_exists (w : W) : ∃ l : list S, is_reduced S w l :=
nat.find_spec (len_exists S w)

lemma generates_of_generated_group [generated_group W S] : subgroup.closure S = ⊤ :=
begin
  apply le_antisymm le_top,
  intros w _,
  sorry,
end

-- Bourbaki, Proposition 4.1.1 (1)
lemma len_mul_le (w w' : W) : gen_length S (w * w') ≤ gen_length S w + gen_length S w' :=
begin
    have h1 := nat.find_spec (len_exists S w),
    have h2 := nat.find_spec (len_exists S w'),
    cases h1 with l1 hl1,
    cases h2 with l2 hl2,
    unfold gen_length,
    rw [←hl1.2, ←hl2.2],
    have hgp : gen_by_n S (w*w') (l1.length + l2.length),
         unfold gen_by_n, use l1++l2, split,
         rw [← hl1.1, ← hl2.1], rw coe_append, rw list.prod_append,
         rw list.length_append,
    exact nat.find_le hgp
end

-- Bourbaki, Proposition 4.1.1 (2)
lemma len_inv (w : W) : gen_length S w⁻¹ = gen_length S w :=
begin
   have h : ∀ w, gen_length S w⁻¹ ≤ gen_length S w,
   begin
      intro w,
      apply nat.find_le,
      rcases reduced_exists S w with ⟨l, lgen, llen⟩,
      use [list.reverse (l.map has_inv.inv)], split,
      { 
         simpa [coe_reverse, list_coe_inv, list.prod_reverse_noncomm],
      },
      simp,
      exact llen,
   end,
   have := h w⁻¹,
   simp at this,
   exact le_antisymm (h w) this,
end

-- Bourbaki, Proposition 4.1.1 (3)
lemma le_len_rat (w w' : W) : |(gen_length S w : ℤ) - gen_length S w'| ≤ gen_length S (w * w'⁻¹) :=
begin
    rw abs_le, split,
    rw neg_le_sub_iff_le_add,
    rw [←len_inv S (w * w'⁻¹)], rw mul_inv_rev, rw inv_inv, rw add_comm,
    have h_pr : w' = (w' * w⁻¹) * w, simp,
    nth_rewrite 0 h_pr, 
    have hint := len_mul_le S (w' * w⁻¹) w,
    rw ←int.coe_nat_add,
    rw int.coe_nat_le_coe_nat_iff, exact hint,
    rw sub_le_iff_le_add,
    have h_pr : w = (w * w'⁻¹) * w', simp,
    nth_rewrite 0 h_pr, 
    have hint := len_mul_le S (w * w'⁻¹) w',
    rw ←int.coe_nat_add,
    rw int.coe_nat_le_coe_nat_iff, exact hint,
end

-- Bourbaki, Corollary to Proposition 4.1.1
lemma prod_reduced {l1 l2 : list S} {w1 w2 : W}
(hl1 : (l1 : list W).prod = w1) (hl2 : (l2 : list W).prod = w2)
(hll' : is_reduced S (w1 * w2) (l1 ++ l2)) : 
  is_reduced S w1 l1 ∧ is_reduced S w2 l2 :=
begin
  use [hl1],
  { apply le_antisymm,
    { by_contra',
      rcases reduced_exists S w1 with ⟨l1', hl1', hl1''⟩,
      have h1 : (coe (l1' ++ l2) : list W).prod = w1 * w2 := by simp [coe_append, hl1', hl2],
      have h2 := calc (l1' ++ l2).length < (l1 ++ l2).length      : by simp [hl1'', this]
                                     ... = gen_length S (w1 * w2) : hll'.right,
      apply nat.find_min (len_exists S (w1 * w2)) h2,
      use [l1' ++ l2, h1], },
    apply nat.find_min',
    use [l1, hl1], },
  use [hl2],
  { apply le_antisymm,
    { by_contra',
      rcases reduced_exists S w2 with ⟨l2', hl2', hl2''⟩,
      have h1 : (coe (l1 ++ l2') : list W).prod = w1 * w2 := by simp [coe_append, hl2', hl1],
      have h2 := calc (l1 ++ l2').length < (l1 ++ l2).length      : by simp [hl2'', this]
                                     ... = gen_length S (w1 * w2) : hll'.right,
      apply nat.find_min (len_exists S (w1 * w2)) h2,
      use [l1 ++ l2', h1], },
    apply nat.find_min',
    use [l2, hl2], },
end

section dihedral

#check @subgroup.closure_induction

-- Bourbaki, Proposition 4.2.1 (i)
lemma closure_S_normal {s s' : W} [generated_group W {s,s'}]
(hneq : s ≠ s') (hs : order_of s = 2) (hs' : order_of s' = 2) : 
  (subgroup.zpowers (s * s')).normal :=
begin
  rw subgroup.zpowers_eq_closure,
  constructor,
  sorry,
end


end dihedral

end generated_group

#check generated_group.gen_length

def subset := set ℕ

variable (X : subset)

#check (1 ∈ ↑X)
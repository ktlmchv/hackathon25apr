import coxeter
import data.int.basic
import group_theory.specific_groups.dihedral
import group_theory.specific_groups.cyclic
import algebra.group_power.lemmas

noncomputable theory
open_locale classical

namespace list
/- Lemmas about list coercions -/

variables {S : Type*} {T : set S}

-- Coercion from `list T` to `list S`.
instance list_subtype_to_list : has_coe (list T) (list S) :=
⟨λ l, map subtype.val l⟩

lemma coe_cons (hd : T) (tl : list T) : (coe (hd :: tl) : list S) = coe hd :: coe tl := 
rfl

lemma coe_append (l m : list T) : (coe (l ++ m) : list S) = l ++ m :=
begin
   rw coe, rw list.list_subtype_to_list, apply list.map_append,
end

lemma coe_reverse (l : list T) : (l.reverse : list S) = (l : list S).reverse :=
begin
   induction l with hd tl ih,
   { refl },
   simp [coe_append, coe_cons, ih],
   refl,
end

lemma mem_coe {l : list T} {x : S} (hx : x ∈ (l : list S)) : x ∈ T :=
begin
  rcases mem_map.mp hx with ⟨y, hl, hy⟩,
  rw ← hy,
  exact y.property,
end

end list

-- A group `W` generated by a set `S`, such that `S` contains `1` and `S⁻¹ = S`.
class generated_group (W : Type*) [group W] (S : set W) :=
(inv : S⁻¹ = S) 
(neut : (1 : W) ∉ S)
(gen : ∀ w : W, ∃ l : list S, (l : list W).prod = w)

namespace generated_group

variables {W : Type*} [group W] (S : set W)

/- Some more trivial coercion results -/
instance [h : generated_group W S] : has_inv S :=
⟨λ s,
{ val := s⁻¹,
  property := begin
   apply subset_of_eq h.inv,
   simp,
  end }⟩

lemma list_coe_inv [generated_group W S] (l : list S) :
   (coe (l.map has_inv.inv) : list W) = (coe l : list W).map has_inv.inv :=
begin
   induction l with hd tl ih,
   { refl },
   simp [list.coe_cons, ih],
   refl,
end

-- predicate saying that element w can be prsented as a product of n generators

def gen_by_n (w : W) (n : ℕ) := ∃ l : list S, (l: list W).prod = w ∧ l.length = n
#check gen_by_n

-- proof that any element can be presented as a product of some amount of generators (needed for nat.find)

lemma len_exists [h : generated_group W S] (w : W) : ∃ n, gen_by_n S w n :=
begin
   have h := h.gen w,
   induction h,
   use h_w.length,
   unfold gen_by_n,
   use h_w, 
   split, exact h_h, refl, 
end

-- The length of a group element with respect to a generating set `S`.
-- Bourbaki, Definition 4.1.1
def gen_length [generated_group W S] (w : W) := nat.find (len_exists S w) 

variables [generated_group W S]

-- A list of elements is reduced it has minimal length amongs all lists with the same product.
-- Bourbaki, Definition 4.1.1
def is_reduced (S : set W) (w : W) [generated_group W S] (l : list S) :=
(l : list W).prod = w ∧ l.length = gen_length S w

-- alias for find_spec
lemma reduced_exists (w : W) : ∃ l : list S, is_reduced S w l :=
nat.find_spec (len_exists S w)

lemma closure_eq_top_of_generated_group [hg: generated_group W S] : subgroup.closure S = ⊤ :=
begin
  apply le_antisymm le_top,
  intros w _,
  cases hg.gen w with l hl,
  rw ← hl,
  refine @subgroup.list_prod_mem _ _ _ ↑l _,
  intros x hx,
  exact subgroup.subset_closure (list.mem_coe hx),
end

-- Bourbaki 4.1.1
-- Proposition 1
-- (1)
lemma len_mul_le (w w' : W) : gen_length S (w * w') ≤ gen_length S w + gen_length S w' :=
begin
    have h1 := nat.find_spec (len_exists S w),
    have h2 := nat.find_spec (len_exists S w'),
    cases h1 with l1 hl1,
    cases h2 with l2 hl2,
    unfold gen_length,
    rw [←hl1.2, ←hl2.2],
    have hgp : gen_by_n S (w*w') (l1.length + l2.length),
         unfold gen_by_n, use l1++l2, split,
         rw [← hl1.1, ← hl2.1], rw list.coe_append, rw list.prod_append,
         rw list.length_append,
    exact nat.find_le hgp
end
-- (2)
lemma len_inv (w : W) : gen_length S w⁻¹ = gen_length S w :=
begin
   have h : ∀ w, gen_length S w⁻¹ ≤ gen_length S w,
   begin
      intro w,
      apply nat.find_le,
      rcases reduced_exists S w with ⟨l, lgen, llen⟩,
      use [list.reverse (l.map has_inv.inv)], split,
      { 
         simpa [list.coe_reverse, list_coe_inv, list.prod_reverse_noncomm],
      },
      simp,
      exact llen,
   end,
   have := h w⁻¹,
   simp at this,
   exact le_antisymm (h w) this,
end
-- (3)
lemma le_len_rat (w w' : W) : |(gen_length S w : ℤ) - gen_length S w'| ≤ gen_length S (w * w'⁻¹) :=
begin
    rw abs_le, split,
    rw neg_le_sub_iff_le_add,
    rw [←len_inv S (w * w'⁻¹)], rw mul_inv_rev, rw inv_inv, rw add_comm,
    have h_pr : w' = (w' * w⁻¹) * w, simp,
    nth_rewrite 0 h_pr, 
    have hint := len_mul_le S (w' * w⁻¹) w,
    rw ←int.coe_nat_add,
    rw int.coe_nat_le_coe_nat_iff, exact hint,
    rw sub_le_iff_le_add,
    have h_pr : w = (w * w'⁻¹) * w', simp,
    nth_rewrite 0 h_pr, 
    have hint := len_mul_le S (w * w'⁻¹) w',
    rw ←int.coe_nat_add,
    rw int.coe_nat_le_coe_nat_iff, exact hint,
end

-- Bourbaki, Corollary to Proposition 4.1.1
lemma prod_reduced {l1 l2 : list S} {w1 w2 : W}
(hl1 : (l1 : list W).prod = w1) (hl2 : (l2 : list W).prod = w2)
(hll' : is_reduced S (w1 * w2) (l1 ++ l2)) : 
  is_reduced S w1 l1 ∧ is_reduced S w2 l2 :=
begin
  use [hl1],
  { apply le_antisymm,
    { by_contra',
      rcases reduced_exists S w1 with ⟨l1', hl1', hl1''⟩,
      have h1 : (coe (l1' ++ l2) : list W).prod = w1 * w2 := by simp [list.coe_append, hl1', hl2],
      have h2 := calc (l1' ++ l2).length < (l1 ++ l2).length      : by simp [hl1'', this]
                                     ... = gen_length S (w1 * w2) : hll'.right,
      apply nat.find_min (len_exists S (w1 * w2)) h2,
      use [l1' ++ l2, h1], },
    apply nat.find_min',
    use [l1, hl1], },
  use [hl2],
  { apply le_antisymm,
    { by_contra',
      rcases reduced_exists S w2 with ⟨l2', hl2', hl2''⟩,
      have h1 : (coe (l1 ++ l2') : list W).prod = w1 * w2 := by simp [list.coe_append, hl2', hl1],
      have h2 := calc (l1 ++ l2').length < (l1 ++ l2).length      : by simp [hl2'', this]
                                     ... = gen_length S (w1 * w2) : hll'.right,
      apply nat.find_min (len_exists S (w1 * w2)) h2,
      use [l1 ++ l2', h1], },
    apply nat.find_min',
    use [l2, hl2], },
end

section dihedral
-- Bourbaki 4.1.2
variables {n : ℕ} 
def S_D := ({dihedral_group.sr 1, dihedral_group.sr 2} : set (dihedral_group n)) 
#check (list.repeat [1,2] 3).join
instance : generated_group (dihedral_group n) S_D :=
{
   inv := 
   begin
       unfold S_D, simp only [set.inv_insert, set.inv_singleton],
       have h1 : (dihedral_group.sr 1)⁻¹ = dihedral_group.sr 1, 
       rw inv_eq_iff_mul_eq_one, rw dihedral_group.sr_mul_sr 1 1, rw sub_self, symmetry, have hone := dihedral_group.one_def, exact hone,
       have h2 : (dihedral_group.sr 2)⁻¹ = dihedral_group.sr 2,
       rw inv_eq_iff_mul_eq_one, rw dihedral_group.sr_mul_sr 2 2, rw sub_self, symmetry, have hone := dihedral_group.one_def, exact hone,
       apply set.ext,
       intro x,
       simp only [set.mem_insert_iff, set.mem_singleton_iff],
       split, tauto, tauto, tauto, apply_instance, apply_instance, tauto, apply_instance
   end,
   neut :=
   begin
       intro h, unfold S_D at h, rw set.mem_insert_iff at h, cases h,
       rw dihedral_group.one_def at h, injection h,
       rw set.mem_singleton_iff at h, injection h,
   end,
   gen :=
   begin
       intro w,
       cases w,
       have m1 : dihedral_group.sr 1 ∈ S_D, simp [S_D, set.mem_insert_iff],
       have m2 : dihedral_group.sr 2 ∈ S_D, unfold S_D, rw set.mem_insert_iff,  right, exact set.mem_singleton _, tauto,
       use (list.repeat ([⟨dihedral_group.sr 1, m1⟩, ⟨dihedral_group.sr 2, m2⟩] : list S_D) (w.val)).join,
       have hind : ∀ k : ℕ, ((list.repeat ([dihedral_group.sr 1, dihedral_group.sr 2] : list (dihedral_group n)) k).join).prod = dihedral_group.r (k : zmod n),
       intro k, induction k with k hk, 
       simp, exact dihedral_group.one_def,
       simp[hk], ring, 
       have hinds := hind w.val,
       sorry
--       rw zmod.nat_cast_zmod_val w at hinds,
   end,
}

#check @subgroup.closure_induction

namespace group

lemma order_of_eq_two {G : Type*} [group G] {x : G} (hx : order_of x = 2) : x⁻¹ = x :=
inv_eq_of_mul_eq_one_right (by rw [← pow_two, ← hx, pow_order_of_eq_one])

end group

-- Bourbaki, Proposition 4.2.1 (i)
lemma closure_S_normal {s s' : W} [generated_group W {s,s'}]
(hneq : s ≠ s') (hs : order_of s = 2) (hs' : order_of s' = 2) : 
  (subgroup.zpowers (s * s')).normal :=
begin
  have hp : ∀ n : ℤ, s * (s * s')^n * s = (s * s')^(- n),
  { intro n,
    have hss :=
      calc s * s = s ^ 2 : by rw pow_two
             ... = 1     : by rw [← hs, pow_order_of_eq_one],
    have hpi : (s * s') ^ -(1 : ℤ) = s' * s := 
      by rw [zpow_neg, zpow_one, mul_inv_rev, group.order_of_eq_two hs, group.order_of_eq_two hs'],
    apply int.induction_on' n 0,
    { simp [hss], },
    { intros k hk ih,
      calc s * (s * s') ^ (k + 1) * s = s * (s * s') ^ k * (s * s') * s : by group
        ... = s * (s * s') ^ k * (s * s) * (s * s') * s : by { rw hss, group }
        ... = (s * (s * s') ^ k * s) * (s * s) * (s' * s) : by group
        ... = (s * s') ^ -k * (s' * s) : by { rw [ih, hss], group }
        ... = (s * s') ^ (-k + - (1 : ℤ)) : by rw [← hpi, zpow_add]
        ... = (s * s') ^ -(k + 1) : by ring_nf, },
    { intros k hk ih,
      calc s * (s * s') ^ (k - 1) * s = s * (s * s') ^ k * s' * (s * s) : by { rw [int.sub_eq_add_neg, zpow_add, hpi], group }
        ... = s * (s * s') ^ k * (s * s) * s' : by simp [hss]
        ... = (s * (s * s') ^ k * s) * (s * s') : by group
        ... = (s * s') ^ -k * (s * s') ^ (1 : ℤ) : by rw [ih, zpow_one]
        ... = (s * s') ^ (-k + 1) : by rw zpow_add
        ... = (s * s') ^ -(k - 1) : by ring_nf, } },
  constructor,
  intros n hn w,
  cases subgroup.mem_zpowers_iff.mp hn with k hk,
  sorry,
end


end dihedral

end generated_group

--- scratch

#check generated_group.gen_length

def subset := set ℕ

variable (X : subset)

#check (1 ∈ ↑X)

import group_theory.free_group
import data.matrix.basic
import group_theory.perm.sign
import group_theory.quotient_group
import group_theory.perm.basic
import group_theory.presented_group

universe u
noncomputable theory

/-- A Coxeter matrix is a symmetric matrix with natural numbers, where the diagonal elements are 1. -/
structure coxeter_matrix (S : Type u) :=
(mat : matrix S S ℕ)
(symmetric : ∀ i j, mat i j = mat j i)
(diagonal_one : ∀ i, mat i i = 1)

open group
open subgroup

/-- A Coxeter group is a group generated by a finite set of involutions and relations given by a
Coxeter matrix. -/
def coxeter_group (S : Type u) (M : coxeter_matrix S) :=
quotient_group.quotient.group $
normal_closure {
  w : free_group S | ∃ i j : S, w = (free_group.of i * free_group.of j) ^ (M.mat i j) }

def coxeter_group_relations (S : Type u) (M : coxeter_matrix S) : S × S → free_group S :=
λ p, (free_group.of p.1 * free_group.of p.2) ^ (M.mat p.1 p.2)

def coxeter_group_presented (S : Type u) (M : coxeter_matrix S) :=
presented_group (set.image (coxeter_group_relations S M) (set.univ))

instance coxeter_group_presented_group {S : Type u} {M : coxeter_matrix S} :
  group (coxeter_group_presented S M) :=
presented_group.group _

/-- The standard Coxeter matrix for the symmetric group. -/
def symmetric_group_coxeter_matrix (n : ℕ+) : coxeter_matrix (fin (n - 1)) :=
{ mat := λ i j, if i = j then 1 else if (i : ℕ) + 1 = j ∨ (j : ℕ) + 1 = i then 3 else 2,
  symmetric := λ i j, by {split_ifs, repeat {tauto} },
  diagonal_one := λ i, by simp }

#check symmetric_group_coxeter_matrix 3

variable n : ℕ+

variables {W : Type*} [group W] (S : set W) (hs_inv : S = S⁻¹) (hs_neut : (1 : W) ∉ S)
variables (hs_gen : ∀ w : W, ∃ l : list W, (∀ s ∈ l, s ∈ S) ∧ l.prod = w)


theorem symmetric_group_is_coxeter_group (n : ℕ+):
coxeter_group_presented (fin (n-1)) (symmetric_group_coxeter_matrix n) ≃ ((equiv.perm (fin n)) ) :=
begin
  sorry -- the proof is left as an exercise for the reader
end

